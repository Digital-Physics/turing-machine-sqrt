<!-- Update Note: make all m-config state rules consistent in formatting -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Turing Machine Simulator – √2 (faithful to the book)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg: #0f1117;
    --fg: #e6e6e6;
    --muted: #a9a9b3;
    --accent: #6ee7b7;
    --warn: #fbbf24;
    --danger: #f87171;
    --fcell: #1d2330;      /* F-squares row background */
    --ecell: #1a202c;      /* E-squares row background */
    --head: #93c5fd;       /* head highlight */
    --marker-x: #f59e0b;
    --marker-y: #f472b6;
    --marker-z: #a78bfa;
    --rt-0: #94a3b8;       /* r,s,t (0) */
    --rt-1: #60a5fa;       /* u,v,w (1) */
  }
  html, body {
    background: var(--bg);
    color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    margin: 0;
  }
  header {
    padding: 18px 20px 6px;
    text-align: center;
  }
  header h1 {
    margin: 0 0 8px;
    font-size: 22px;
    font-weight: 700;
  }
  header p {
    margin: 0;
    color: var(--muted);
    font-size: 14px;
  }
  .wrap {
    max-width: 1100px;
    margin: 18px auto 60px;
    padding: 0 16px;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 14px;
  }
  .controls button, .controls select {
    background: #1d2336;
    color: var(--fg);
    border: 1px solid #2c3647;
    border-radius: 10px;
    padding: 8px 14px;
    cursor: pointer;
    font-weight: 600;
  }
  .controls button:hover, .controls select:hover { border-color: #3a465b; }
  .controls .danger { border-color: var(--danger); color: var(--danger); }
  .statusbar {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 12px;
    font-size: 14px;
    color: var(--muted);
  }
  .statusbar div b { color: var(--fg); }
  .board {
    background: #0c0f16;
    border: 1px solid #1a2333;
    border-radius: 14px;
    padding: 14px;
  }
  .tape {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .tape-label {
    color: var(--muted);
    font-weight: 700;
    font-size: 14px;
    text-align: center;
    margin-bottom: 8px;
  }
  .row {
    overflow-x: auto;
    border: 1px solid #1f2a3d;
    border-radius: 10px;
    background: #0c121d;
    padding: 10px;
  }
  .cells {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: minmax(32px, 40px);
    gap: 6px;
  }
  .cell {
    height: 40px;
    border-radius: 8px;
    display: grid;
    place-items: center;
    font-weight: 800;
    letter-spacing: 0.4px;
    border: 1px solid #273149;
    position: relative;
  }
  .cell.f { background: var(--fcell); }
  .cell.e { background: var(--ecell); }
  .cell .idx {
    position: absolute;
    top: -8px;
    font-size: 10px;
    color: var(--muted);
  }
  .cell.head { outline: 3px solid var(--head); z-index: 2; }
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 18px;
    margin-top: 12px;
    color: var(--muted);
    font-size: 12px;
  }
  .chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .dot {
    width: 10px; height: 10px; border-radius: 999px;
  }
  .dot.x { background: var(--marker-x); }
  .dot.y { background: var(--marker-y); }
  .dot.z { background: var(--marker-z); }
  .dot.r0 { background: var(--rt-0); }
  .dot.r1 { background: var(--rt-1); }
  .log {
    margin-top: 16px;
    height: 200px;
    overflow: auto;
    border: 1px solid #1a2333;
    border-radius: 10px;
    background: #0b0f17;
    padding: 10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size: 12.5px;
  }
  .log .entry { margin: 0 0 6px; white-space: pre; }
  .hl-x { color: var(--marker-x); font-weight: 700; }
  .hl-y { color: var(--marker-y); font-weight: 700; }
  .hl-z { color: var(--marker-z); font-weight: 700; }
  .hl0 { color: var(--rt-0); font-weight: 700; }
  .hl1 { color: var(--rt-1); font-weight: 700; }
  .hlh { color: var(--head); font-weight: 700; }
  .hls { color: var(--accent); font-weight: 700; }
  footer {
    text-align: center;
    color: var(--muted);
    font-size: 12px;
    margin: 16px 0 40px;
  }
</style>
</head>
<body>
  <header>
    <h1>√2 Turing Machine – step-by-step simulator</h1>
    <p>A Turing Machine that computes the square root of 2 like the example in Ch. 6 of "Annotated Turing" by Charles Petzold.</p>
  </header>

  <div class="wrap">
    <div class="controls">
      <button id="btnStep">Step</button>
      <button id="btnRun">Run</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset" class="danger">Reset</button>
      <label style="margin-left:8px;">Speed:
        <select id="speed">
          <option value="800">Slow</option>
          <option value="400" selected>Medium</option>
          <option value="160">Fast</option>
          <option value="60">Very Fast</option>
        </select>
      </label>
      <span id="msg" style="margin-left:auto;color:var(--warn);"></span>
    </div>

    <div class="statusbar">
      <div>State: <b id="state">begin</b></div>
      <div>Head @ index: <b id="head">0</b></div>
      <div>Digits so far: <b id="digits">â€"</b></div>
    </div>

    <div class="board">
      <div class="tape">
        <div class="tape-label">A Turing Machine Tape with Interleaved F-squares (digits) and E-squares (workspace)</div>
        <div class="row"><div id="interleaved" class="cells"></div></div>
      </div>
      <div class="legend">
        <span class="chip"><span class="dot x"></span>x marker</span>
        <span class="chip"><span class="dot y"></span>y marker</span>
        <span class="chip"><span class="dot z"></span>z marker (= x & y coincide)</span>
        <span class="chip"><span class="dot r0"></span>r/s/t → 0</span>
        <span class="chip"><span class="dot r1"></span>u/v/w → 1</span>
        <!-- <span>Head = blue outline | F-squares = darker | E-squares = lighter</span> -->
      </div>
      <div id="log" class="log"></div>
    </div>

    <footer id="sqrt-display"></footer>
  </div>

<script>
/* ============================================================
   √2 Turing Machine (faithful visual simulator)
   ------------------------------------------------------------
   This simulator implements the m-configurations from the book
   "The Annotated Turing" by Charles Petzold. Each state function
   corresponds to an m-configuration table from the book.
   ============================================================ */

/*** Tape model ***/
const BLANK = " ";
const SENTINEL = "@";
const RT0 = new Set(["r","s","t"]);
const RT1 = new Set(["u","v","w"]);

function symbolClass(sym) {
  if (sym === "x") return "hl-x";
  if (sym === "y") return "hl-y";
  if (sym === "z") return "hl-z";
  if (RT0.has(sym)) return "hl0";
  if (RT1.has(sym)) return "hl1";
  if (sym === SENTINEL) return "hls";
  if (sym === "0" || sym === "1") return "";
  return "muted";
}

let tape = [];
let head = 0;
let state = "begin";
let sub_state = 0; // For multi-step operations within a single m-config
let inSubprocess = false; // Flag to prevent re-reading symbol during subprocess
let lastReadSymbol = null; // Store the symbol that initiated the current subprocess
let running = false;
let timer = null;
let stepCount = 0;

function toBinaryFraction(x, bits) {
  const intPart = Math.floor(x);
  let frac = x - intPart;
  let out = intPart.toString(2) + ".";

  for (let i = 0; i < bits; i++) {
    frac *= 2;
    if (frac >= 1) {
      out += "1";
      frac -= 1;
    } else {
      out += "0";
    }
  }
  return out;
}

function initialize() {
  tape = [BLANK];
  head = 0;
  state = "begin";
  sub_state = 0;
  inSubprocess = false;
  lastReadSymbol = null;
  stepCount = 0;
  logClear();
  render();
  setMsg("");
  const sqrtDiv = document.getElementById('sqrt-display');
  sqrtDiv.textContent = Math.SQRT2 + " in binary: " + toBinaryFraction(Math.SQRT2, 20) + "...";
}

/*** Rendering ***/

function render() {
  const digits = tape.filter((s, i) => i % 2 === 1 && (s === "0" || s === "1")).join("") || "–";
  document.getElementById("state").textContent = state + (sub_state > 0 ? ` (step ${sub_state})` : "");
  document.getElementById("head").textContent = String(head);
  document.getElementById("digits").textContent = digits;

  const interleavedRow = document.getElementById("interleaved");
  interleavedRow.innerHTML = "";

  const maxLen = Math.max(tape.length, 30);
  while (tape.length < maxLen) tape.push(BLANK);

  for (let i = 0; i < maxLen; i++) {
    const cell = document.createElement("div");
    const isF = i % 2 === 1;
    cell.className = `cell ${isF ? 'f' : 'e'}${i === head ? " head" : ""}`;
    const sym = tape[i] ?? BLANK;
    const label = isF ? `F${i}` : `E${i}`;
    cell.innerHTML = `<span class="idx">${label}</span><span class="${symbolClass(sym)}">${sym === BLANK ? "·" : sym}</span>`;
    interleavedRow.appendChild(cell);
  }
}

/*** Logging & Controls ***/
const logEl = document.getElementById("log");
function log(msg) {
  const div = document.createElement("div");
  div.className = "entry";
  div.textContent = `[${stepCount}] ${state}: ${msg}`;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}
function logClear() { logEl.innerHTML = ""; }
function setMsg(s)  { document.getElementById("msg").textContent = s; }
initialize();

/*** Tape Operations ***/
function read() { return tape[head] ?? BLANK; }
function write(sym) { tape[head] = sym; }
function moveL() { head = Math.max(0, head-1); }
function moveR() {
  head += 1;
  if (head >= tape.length) { tape.push(BLANK); }
}

function changeState(newState) {
    log(`→ transitioning to m-config. state: ${newState}`);
    state = newState;
    sub_state = 0;
    inSubprocess = false;
    lastReadSymbol = null;
}

/*** Main Machine Step Function ***/
function step() {
  // if (state === "halt") { setMsg("HALT"); return; }
  stepCount++;
  setMsg("");

  // Dispatch to the function for the current m-configuration
  switch (state) {
    case "begin": st_begin(); break;
    case "new": st_new(); break;
    case "mark-digits": st_mark_digits(); break;
    case "find-x": st_find_x(); break;
    case "first-r": st_first_r(); break;
    case "last-r": st_last_r(); break;
    case "find-digits": st_find_digits(); break;
    case "find-1st-digit": st_find_1st_digit(); break;
    case "found-1st-digit": st_found_1st_digit(); break;
    case "find-2nd-digit": st_find_2nd_digit(); break;
    case "found-2nd-digit": st_found_2nd_digit(); break;
    case "add-zero": st_add_zero(); break;
    case "add-one": st_add_one(); break;
    case "carry": st_carry(); break;
    case "add-finished": st_add_finished(); break;
    case "erase-old-x": st_erase_old_x(); break;
    case "print-new-x": st_print_new_x(); break;
    case "erase-old-y": st_erase_old_y(); break;
    case "print-new-y": st_print_new_y(); break;
    case "reset-new-x": st_reset_new_x(); break;
    case "flag-result-digits": st_flag_result_digits(); break;
    case "unflag-result-digits": st_unflag_result_digits(); break;
    case "new-digit-is-zero": st_new_digit_is_zero(); break;
    case "print-zero-digit": st_print_zero_digit(); break;
    case "new-digit-is-one": st_new_digit_is_one(); break;
    case "print-one-digit": st_print_one_digit(); break;
    case "cleanup": st_cleanup(); break;
    // default:
    //   setMsg("Unknown state: "+state);
    //   changeState("halt");
    //   break;
  }
  
  render();
}

/*** M-Configuration (State) Functions ***/

// m-config | symbol | operations | final m-config
// begin | none | P@, R, P1 | new
function st_begin() {
    if (!inSubprocess) {
      lastReadSymbol = read();
      log(`read '${lastReadSymbol}'`);
      inSubprocess = true;
    }

    if (lastReadSymbol === BLANK) {
      switch(sub_state) {
        case 0:
            log("P@; Print @, the sentinel");
            write(SENTINEL);
            sub_state++;
            break;
        case 1:
            log("R; move right");
            moveR();
            sub_state++;
            break;
        case 2:
            log("P1; print 1");
            write("1");
            sub_state++;
            break;
        case 3:
            changeState("new");
            break;
      }
    }
}

// m-config | symbol | operations | final m-config
// new | @ | R | mark-digits
// new | else | L | new
function st_new() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }

    if (lastReadSymbol === SENTINEL) {
        // Rule: move R → mark-digits
        switch(sub_state) {
            case 0:
                log("moving R");
                moveR();
                sub_state++;
                break;
            case 1:
                changeState("mark-digits");
                break;
        }
    } else {
        // Rule: move L → new
        switch(sub_state) {
            case 0:
                log("moving L");
                moveL();
                sub_state++;
                break;
            case 1:
                changeState("new");
                break;
        }
    }
}

// m-config | symbol | operations | final m-config
// mark-digits| 0 or 1 | R, Px, R | mark-digits
// mark-digits| none | R, Pz, R, R, Pr | find-x
function st_mark_digits() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }
    
    if (lastReadSymbol === '0' || lastReadSymbol === '1') {
        switch(sub_state) {
            case 0:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 1:
                log(`writing 'x'`);
                write('x');
                sub_state++;
                break;
            case 2:
                log(`moving R`);
                sub_state++;
                moveR();
            case 3:
                changeState('mark-digits');
                break;
        }
    } else if (lastReadSymbol === BLANK) {
        switch(sub_state) {
            case 0:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 1:
                log(`writing 'z'`);
                write('z');
                sub_state++;
                break;
            case 2:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 3:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 4:
                log(`writing 'r'`);
                write('r');
                sub_state++;
                break;
            case 5:
                changeState('find-x');
                break;
        }
    }
}

// m-config | symbol | operations | final m-config
// find-x | x | E | first-r
// find-x | @ | N | find-digits
// find-x | else | L, L | find-x
function st_find_x() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }

  if (lastReadSymbol === 'x') {
    switch(sub_state) {
    case 0:
        log(`erasing 'x'`);
        write(BLANK); // E operation
        sub_state++;
        break;
    case 1:
        changeState('first-r');
        break;
    }
  } else if (lastReadSymbol === SENTINEL) {
    changeState('find-digits'); // N operation
  } else {
    switch(sub_state) {
      case 0:
        log(`moving L`);
        moveL(); // First L
        sub_state++;
        break;
      case 1:
        log(`moving L again`);
        moveL(); // Second L
        sub_state++;
        break;
      case 2:
        changeState('find-x'); // Reset for next cycle, stay in find-x
        break;
    }
  }
}

// Update Note: update logic to be consistent even thought it's equivalent
// m-config | symbol | operations | final m-config
// first-r | r | R, R | last-r
// first-r | else | R, R | first-r
function st_first_r() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }
    
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log(`moving R again`);
            moveR();
            sub_state++;
            break;
        case 2:
            if (lastReadSymbol === 'r') {
                changeState('last-r');
            } else {
                changeState('first-r'); // Stay in first-r
            }
            break;
    }
}

// m-config | symbol | operations | final m-config
// last-r | r | R, R | last-r
// last-r | none | Pr, R, R, Pr | find-x
function st_last_r() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }
    
    if (lastReadSymbol === BLANK) {
        switch(sub_state) {
            case 0:
                log(`writing 'r'`);
                write('r');
                sub_state++;
                break;
            case 1:
                log('moving R');
                moveR();
                sub_state++;
                break;
            case 2:
                log('moving R');
                moveR();
                sub_state++;
                break;
            case 3:
                log(`writing 'r'`);
                write('r');
                sub_state++;
                break;
            case 4:
                changeState('find-x');
                break;
        }
    } else if (lastReadSymbol === 'r') {
        switch(sub_state) {
            case 0:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 1:
                log('moving R again');
                moveR();
                sub_state++;
                break;
            case 2:
                changeState('last-r'); // Reset for next cycle
                break;
        }
    }
}

// m-config | symbol | operations | final m-config
// find-digits | @ | R, R | find-1st-digit
// find-digits | else | L, L | find-digits
function st_find_digits() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === SENTINEL) {
      switch(sub_state) {
          case 0:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 1:
              log(`moving R again`);
              moveR();
              sub_state++;
              break;
          case 2:
              changeState('find-1st-digit');
              break;
      }
  } else {
      switch(sub_state) {
          case 0:
              log(`moving L`);
              moveL();
              sub_state++;
              break;
          case 1:
              log(`moving L again`);
              moveL();
              sub_state++;
              break;
          case 2:
              changeState('find-digits');
              break;
      }
  }
}

// Update Note: make this consistent with other formats; don't use switch at the read level, use if
// m-config | symbol | operations | final m-config
// find-1st-digit | x/y/z | L | ...
// find-1st-digit | none | R, R | find-1st-digit
function st_find_1st_digit() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  switch(lastReadSymbol) {
    case 'x':
    case 'y':
      log(`moving L`);
      moveL();
      changeState('found-1st-digit');
      break;
    case 'z':
      log(`moving L`);
      moveL();
      changeState('found-2nd-digit');
      break;
    default: // Covers BLANK ('none') (and other symbols, but there shouldn't be other symbols)
      switch(sub_state) {
          case 0:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 1:
              log(`moving R again`);
              moveR();
              sub_state++;
              break;
          case 2:
              changeState('find-1st-digit');
              break;
      }
      break;
  }
}

// Update Note: Reformat to be consistent
// m-config | symbol | operations | final m-config
// found-1st-digit | 0 | R | add-zero
// found-1st-digit | 1 | R, R, R | find-2nd-digit
function st_found_1st_digit() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === '0') {
    log(`moving R`);
    moveR();
    changeState('add-zero');
  } else if (lastReadSymbol === '1') {
      switch(sub_state) {
          case 0:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 1:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 2:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 3:
              changeState('find-2nd-digit');
              break;
      }
  }
}

// m-config | symbol | operations | final m-config
// find-2nd-digit | x/y | L | found-2nd-digit
// find-2nd-digit | none | R, R | find-2nd-digit
function st_find_2nd_digit() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === 'x' || lastReadSymbol === 'y') {
    log(`moving L`);
    moveL();
    changeState('found-2nd-digit');
  } else if (lastReadSymbol === BLANK) {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log(`moving R again`);
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('find-2nd-digit');
            break;
    }
  }
}

// Update Note: make consistent
// m-config | symbol | operations | final m-config
// found-2nd-digit | 0 | R | add-zero
// found-2nd-digit | 1 | R | add-one
// found-2nd-digit | none | R | add-one
function st_found_2nd_digit() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
  }
  
  log(`moving R`);
  moveR();
  if (lastReadSymbol === '0') {
    changeState('add-zero');
  } else { // Covers '1' and BLANK ('none'), both add 1
    changeState('add-one');
  }
}

// m-config | symbol | operations | final m-config
// add-zero | r/u | Ps/Pv | add-finished
// add-zero | else | R, R | add-zero
function st_add_zero() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === 'r') {
    log(`writing 's'`);
    write('s');
    changeState('add-finished');
  } else if (lastReadSymbol === 'u') {
    log(`writing 'v'`);
    write('v');
    changeState('add-finished');
  } else {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log(`moving R again`);
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('add-zero');
            break;
    }
  }
}

// m-config | symbol | operations | final m-config
// add-one | r | Pv | add-finished
// add-one | u | Ps, R, R | carry
// add-one | else | R, R | add-one
function st_add_one() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === 'r') {
    log(`writing 'v'`);
    write('v');
    changeState('add-finished');
  } else if (lastReadSymbol === 'u') {
    switch(sub_state) {
        case 0:
            log(`writing 's'`);
            write('s');
            sub_state++;
            break;
        case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
        case 2:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 3:
            changeState('carry');
            break;
    }
  } else {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('add-one');
            break;
    }
  }
}

// m-config | symbol | operations | final m-config
// carry | r/none | Pu | ...
// carry | u | Pr, R, R | carry
function st_carry() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === 'r') {
    log(`writing 'u'`);
    write('u');
    changeState('add-finished');
  } else if (lastReadSymbol === BLANK) {
    log(`writing 'u'`);
    write('u');
    changeState('new-digit-is-zero');
  } else if (lastReadSymbol === 'u') {
      switch(sub_state) {
          case 0:
            log(`writing 'r'`);
            write('r');
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state++;
            break;
          case 3:
            changeState('carry'); // Reset for next cycle
            break;
      }
  } 
}

// m-config | symbol | operations | final m-config
// add-finished | @ | R, R | erase-old-x
// add-finished | else | L, L | add-finished
function st_add_finished() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === SENTINEL) {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('erase-old-x');
            break;
    }
  } else {
    switch(sub_state) {
        case 0:
            log(`moving L`);
            moveL();
            sub_state++;
            break;
        case 1:
            log('moving L again');
            moveL();
            sub_state++;
            break;
        case 2:
            changeState('add-finished');
            break;
    }
  }
}

// Update Note: Make format consistent and remove opSequence function
// m-config | symbol | operations | final m-config
// erase-old-x | x | E, L, L | print-new-x
// erase-old-x | z | Py, L, L | print-new-x
// erase-old-x | else | R, R | erase-old-x
function st_erase_old_x() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  const opSequence = (writeSym) => {
      switch(sub_state) {
          case 0:
              log(`writing '${writeSym}'`);
              write(writeSym);
              sub_state++;
              break;
          case 1:
              log('moving L');
              moveL();
              sub_state++;
              break;
          case 2:
              log('moving L again');
              moveL();
              changeState('print-new-x');
              break;
      }
  };

  if (lastReadSymbol === 'x') {
      opSequence(BLANK);
  } else if (lastReadSymbol === 'z') {
      opSequence('y');
  } else {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('erase-old-x');
            break;
    }
  }
}

// m-config | symbol | operations | final m-config
// print-new-x | @ | R, R | erase-old-y
// print-new-x | y | Pz | find-digits
// print-new-x | none | Px | find-digits
function st_print_new_x() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === SENTINEL) {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('erase-old-y');
            break;
    }
  } else if (lastReadSymbol === 'y') {
    log(`writing 'z'`);
    write('z');
    changeState('find-digits');
  } else if (lastReadSymbol === BLANK) {
    log(`writing 'x'`);
    write('x');
    changeState('find-digits');
  }
}

// m-config | symbol | operations | final m-config
// erase-old-y | y | E, L, L | print-new-y
// erase-old-y | else | R, R | erase-old-y
function st_erase_old_y() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }
    
    if(lastReadSymbol === 'y') {
        switch(sub_state) {
            case 0:
                log(`erasing`);
                write(BLANK);
                sub_state++;
                break;
            case 1:
                log('moving L');
                moveL();
                sub_state++;
                break;
            case 2:
                log('moving L again');
                moveL();
                sub_state++;
                break;
            case 3:
                changeState('print-new-y');
                break;
        }
    } else {
        switch(sub_state) {
            case 0:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 1:
                log('moving R again');
                moveR();
                sub_state++;
                break;
            case 2:
                changeState('erase-old-y');
                break;
        }
    }
}

// m-config | symbol | operations | final m-config
// print-new-y | @ | R | new-digit-is-one
// print-new-y | else | Py, R | reset-new-x
function st_print_new_y() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === SENTINEL) {
    log(`moving R`);
    moveR();
    changeState('new-digit-is-one');
  } else {
    switch(sub_state) {
        case 0:
            log(`writing 'y'`);
            write('y');
            sub_state++;
            break;
        case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('reset-new-x');
            break;
    }
  }
}

// m-config | symbol | operations | final m-config
// reset-new-x | none | R, Px | flag-result-digits
// reset-new-x | else | R, R | reset-new-x
function st_reset_new_x() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === BLANK) {
      switch(sub_state) {
          case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
          case 1:
            log(`writing 'x'`);
            write('x');
            sub_state++;
            break;
          case 2:
            changeState('flag-result-digits');
            break;
      }
  } else {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('reset-new-x');
            break;
    }
  }
}

// m-config | symbol | operations | final m-config
// flag-result-digits | s | Pt, R, R | unflag-result-digits
// flag-result-digits | v | Pw, R, R | unflag-result-digits
// flag-result-digits | else | R, R | flag-result-digits
function st_flag_result_digits() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  const opSequence = (writeSym) => {
      switch(sub_state) {
          case 0:
            log(`writing '${writeSym}'`);
            write(writeSym);
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state++;
            break;
          case 3:
            changeState('unflag-result-digits');
            break;
      }
  };

  if (lastReadSymbol === 's') {
    opSequence('t');
  } else if (lastReadSymbol === 'v') {
    opSequence('w');
  } else {
    switch(sub_state) {
        case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
        case 1:
            log('moving R again');
            moveR();
            sub_state++;
            break;
        case 2:
            changeState('flag-result-digits');
            break;
    }
  }
}

// m-config | symbol | operations | final m-config
// unflag-result-digits | s | Pr, R, R | unflag-result-digits
// unflag-result-digits | v | Pu, R, R | unflag-result-digits
// unflag-result-digits | else | N | find-digits
function st_unflag_result_digits() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }
    
    const opSequence = (writeSym) => {
        switch(sub_state) {
            case 0:
                log(`writing '${writeSym}'`);
                write(writeSym);
                sub_state++;
                break;
            case 1:
                log('moving R');
                moveR();
                sub_state++;
                break;
            case 2:
                log('moving R again');
                moveR();
                sub_state++;
                break;
            case 3:
                changeState('unflag-result-digits'); // stay in state
                break;
        }
    };
    
    if (lastReadSymbol === 's') {
        opSequence('r');
    } else if (lastReadSymbol === 'v') {
        opSequence('u');
    } else {
        changeState('find-digits');
    }
}

// m-config | symbol | operations | final m-config
// new-digit-is-zero | @ | R | print-zero-digit
// new-digit-is-zero | else | L | new-digit-is-zero
function st_new_digit_is_zero() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
  }
  
  if (lastReadSymbol === SENTINEL) {
    log(`moving R`);
    moveR();
    changeState('print-zero-digit');
  } else {
    log(`moving L`);
    moveL();
    changeState('new-digit-is-zero');
  }
}

// m-config | symbol | operations | final m-config
// print-zero-digit | 0/1 | R, E, R | print-zero-digit
// print-zero-digit | none | P0, R, R | cleanup
function st_print_zero_digit() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === '0' || lastReadSymbol === '1') {
      switch(sub_state) {
          case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
          case 1:
            log('erasing marker');
            write(BLANK);
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            changeState('print-zero-digit');
            break;
      }
  } else if (lastReadSymbol === BLANK) {
      switch(sub_state) {
          case 0:
            log(`writing '0'`);
            write('0');
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state++;
            break;
          case 3:
            log('moving R a third time');
            moveR();
            sub_state++;
            break;
          case 4:
            changeState('cleanup');
            break;
      }
  }
}

// m-config | symbol | operations | final m-config
// new-digit-is-one | @ | R | print-one-digit
// new-digit-is-one | else | L | new-digit-is-one
function st_new_digit_is_one() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
  }
  
  if (lastReadSymbol === SENTINEL) {
    log(`moving R`);
    moveR();
    changeState('print-one-digit');
  } else {
    log(`moving L`);
    moveL();
    changeState('new-digit-is-one');
  }
}

// m-config | symbol | operations | final m-config
// print-one-digit | 0/1 | R, E, R | print-one-digit
// print-one-digit | none | P1, R, R, R | cleanup
function st_print_one_digit() {
  if (!inSubprocess) {
    lastReadSymbol = read();
    log(`read '${lastReadSymbol}'`);
    inSubprocess = true;
    sub_state = 0;
  }
  
  if (lastReadSymbol === '0' || lastReadSymbol === '1') {
      switch(sub_state) {
          case 0:
            log(`moving R`);
            moveR();
            sub_state++;
            break;
          case 1:
            log('erasing marker');
            write(BLANK);
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state++;
            break;
          case 3:
            changeState('print-one-digit');
            break;
      }
  } else if (lastReadSymbol === BLANK) {
      switch(sub_state) {
          case 0:
            log(`writing '1'`);
            write('1');
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state++;
            break;
          case 3:
            log('moving R third time');
            moveR();
            sub_state++;
            break;
          case 4:
            changeState('cleanup');
            break;
      }
  }
}

// m-config | symbol | operations | final m-config
// cleanup | none | N | new
// cleanup | else | E, R, R | cleanup
function st_cleanup() {
    if (!inSubprocess) {
        lastReadSymbol = read();
        log(`read '${lastReadSymbol}'`);
        inSubprocess = true;
        sub_state = 0;
    }
    
    if (lastReadSymbol === BLANK) {
        changeState('new');
    } else {
        switch(sub_state) {
            case 0:
                log(`erasing marker`);
                write(BLANK);
                sub_state++;
                break;
            case 1:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 2:
                log('moving R again');
                moveR();
                sub_state++;
                break;
            case 3:
                changeState('cleanup');
                break;
        }
    }
}

/*** UI Controls ***/
document.getElementById("btnStep").addEventListener("click", ()=> {
  if (!running) { step(); }
});
document.getElementById("btnRun").addEventListener("click", ()=> {
  if (running) return;
  running = true;
  const speedSel = document.getElementById("speed");
  const delay = parseInt(speedSel.value, 10);
  timer = setInterval(()=> {
    if (running) step();
    else clearInterval(timer);
  }, delay);
});
document.getElementById("btnPause").addEventListener("click", ()=> {
  running = false;
  clearInterval(timer);
});
document.getElementById("btnReset").addEventListener("click", ()=> {
  running = false;
  clearInterval(timer);
  initialize();
});
</script>
</body>
</html>