<!-- update needed: 1) There is one Tape not an E and F tape. Mostly converted but may still be buggy. -->
<!-- update needed: 2a) There should be a render after each step in a process, not just at m-config state change -->
<!-- update needed: 2b) All subprocesses that run in a m-config state should be handled under the if condition with renders in between steps. substate not needed; don't leave and come back into function or you'll be checking the symbol again before completing all subprocesses.-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Turing Machine Simulator – √2 (faithful to the book)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg: #0f1117;
    --fg: #e6e6e6;
    --muted: #a9a9b3;
    --accent: #6ee7b7;
    --warn: #fbbf24;
    --danger: #f87171;
    --fcell: #1d2330;      /* F-squares row background */
    --ecell: #1a202c;      /* E-squares row background */
    --head: #93c5fd;       /* head highlight */
    --marker-x: #f59e0b;
    --marker-y: #f472b6;
    --marker-z: #a78bfa;
    --rt-0: #94a3b8;       /* r,s,t (0) */
    --rt-1: #60a5fa;       /* u,v,w (1) */
  }
  html, body {
    background: var(--bg);
    color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    margin: 0;
  }
  header {
    padding: 18px 20px 6px;
    text-align: center;
  }
  header h1 {
    margin: 0 0 8px;
    font-size: 22px;
    font-weight: 700;
  }
  header p {
    margin: 0;
    color: var(--muted);
    font-size: 14px;
  }
  .wrap {
    max-width: 1100px;
    margin: 18px auto 60px;
    padding: 0 16px;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 14px;
  }
  .controls button, .controls select {
    background: #1d2336;
    color: var(--fg);
    border: 1px solid #2c3647;
    border-radius: 10px;
    padding: 8px 14px;
    cursor: pointer;
    font-weight: 600;
  }
  .controls button:hover, .controls select:hover { border-color: #3a465b; }
  .controls .danger { border-color: var(--danger); color: var(--danger); }
  .statusbar {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 12px;
    font-size: 14px;
    color: var(--muted);
  }
  .statusbar div b { color: var(--fg); }
  .board {
    background: #0c0f16;
    border: 1px solid #1a2333;
    border-radius: 14px;
    padding: 14px;
  }
  .tape {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .tape-label {
    color: var(--muted);
    font-weight: 700;
    font-size: 14px;
    text-align: center;
    margin-bottom: 8px;
  }
  .row {
    overflow-x: auto;
    border: 1px solid #1f2a3d;
    border-radius: 10px;
    background: #0c121d;
    padding: 10px;
  }
  .cells {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: minmax(32px, 40px);
    gap: 6px;
  }
  .cell {
    height: 40px;
    border-radius: 8px;
    display: grid;
    place-items: center;
    font-weight: 800;
    letter-spacing: 0.4px;
    border: 1px solid #273149;
    position: relative;
  }
  .cell.f { background: var(--fcell); }
  .cell.e { background: var(--ecell); }
  .cell .idx {
    position: absolute;
    top: -8px;
    font-size: 10px;
    color: var(--muted);
  }
  .cell.head { outline: 3px solid var(--head); z-index: 2; }
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 18px;
    margin-top: 12px;
    color: var(--muted);
    font-size: 12px;
  }
  .chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .dot {
    width: 10px; height: 10px; border-radius: 999px;
  }
  .dot.x { background: var(--marker-x); }
  .dot.y { background: var(--marker-y); }
  .dot.z { background: var(--marker-z); }
  .dot.r0 { background: var(--rt-0); }
  .dot.r1 { background: var(--rt-1); }
  .log {
    margin-top: 16px;
    height: 200px;
    overflow: auto;
    border: 1px solid #1a2333;
    border-radius: 10px;
    background: #0b0f17;
    padding: 10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size: 12.5px;
  }
  .log .entry { margin: 0 0 6px; white-space: pre; }
  .hl-x { color: var(--marker-x); font-weight: 700; }
  .hl-y { color: var(--marker-y); font-weight: 700; }
  .hl-z { color: var(--marker-z); font-weight: 700; }
  .hl0 { color: var(--rt-0); font-weight: 700; }
  .hl1 { color: var(--rt-1); font-weight: 700; }
  .hlh { color: var(--head); font-weight: 700; }
  .hls { color: var(--accent); font-weight: 700; }
  footer {
    text-align: center;
    color: var(--muted);
    font-size: 12px;
    margin: 16px 0 40px;
  }
</style>
</head>
<body>
  <header>
    <h1>√2 Turing Machine – faithful step-by-step simulator</h1>
    <p>Interleaved F-squares (digits) and E-squares (workspace) like in the book. Step through the exact m-configurations.</p>
  </header>

  <div class="wrap">
    <div class="controls">
      <button id="btnStep">Step</button>
      <button id="btnRun">Run</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset" class="danger">Reset</button>
      <label style="margin-left:8px;">Speed:
        <select id="speed">
          <option value="800">Slow</option>
          <option value="400" selected>Medium</option>
          <option value="160">Fast</option>
          <option value="60">Very Fast</option>
        </select>
      </label>
      <span id="msg" style="margin-left:auto;color:var(--warn);"></span>
    </div>

    <div class="statusbar">
      <div>State: <b id="state">begin</b></div>
      <div>Head @ index: <b id="head">0</b></div>
      <div>Digits so far: <b id="digits">—</b></div>
    </div>

    <div class="board">
      <div class="tape">
        <div class="tape-label">Interleaved F-squares and E-squares</div>
        <div class="row"><div id="interleaved" class="cells"></div></div>
      </div>
      <div class="legend">
        <span class="chip"><span class="dot x"></span>x marker</span>
        <span class="chip"><span class="dot y"></span>y marker</span>
        <span class="chip"><span class="dot z"></span>z marker (= x & y coincide)</span>
        <span class="chip"><span class="dot r0"></span>r/s/t → 0</span>
        <span class="chip"><span class="dot r1"></span>u/v/w → 1</span>
        <span>Head = blue outline | F-squares = darker | E-squares = lighter</span>
      </div>
      <div id="log" class="log"></div>
    </div>

    <footer>
      Built to mirror the states and markers described in the book's √2 machine (Petzold). It logs every micro-step: reads, writes, moves, and state transitions.
    </footer>
  </div>

<script>
/* ============================================================
   √2 Turing Machine (faithful visual simulator)
   ------------------------------------------------------------
   This simulator implements the m-configurations from the book
   "The Annotated Turing" by Charles Petzold. Each state function
   corresponds to an m-configuration table from the book.
   ============================================================ */

/*** Tape model ***/
const BLANK = " ";
const SENTINEL = "@";
const RT0 = new Set(["r","s","t"]);
const RT1 = new Set(["u","v","w"]);

function symbolClass(sym) {
  if (sym === "x") return "hl-x";
  if (sym === "y") return "hl-y";
  if (sym === "z") return "hl-z";
  if (RT0.has(sym)) return "hl0";
  if (RT1.has(sym)) return "hl1";
  if (sym === SENTINEL) return "hls";
  if (sym === "0" || sym === "1") return "";
  return "muted";
}

// Update Needed: there shouldn't be E and F cells with their own index; there should be one tape where E and F cells are next to each other and the indexes happen to be even and odd
// moving Right from and F cell with 1 in it should put you in an E cell with potentially a blank or a tag in it
let tape = [] // use this combined tape instead of F and E
// let F = [];
// let E = [];
let head = 0;
let state = "begin";
let sub_state = 0; // For multi-step operations within a single m-config
let running = false;
let timer = null;
let stepCount = 0;

function initialize() {
  tape[BLANK]
  // F = [BLANK];
  // E = [BLANK];
  head = 0;
  state = "begin";
  sub_state = 0;
  stepCount = 0;
  logClear();
  render();
  setMsg("");
}

/*** Rendering ***/

// const E_TAPE_STATES = new Set([
//     'find-x',
//     'first-r',
//     'last-r',
//     'find-1st-digit',
//     'find-2nd-digit',
//     'add-zero',
//     'add-one',
//     'carry',
//     'erase-old-x',
//     'print-new-x',
//     'erase-old-y',
//     'print-new-y',
//     'reset-new-x',
//     'flag-result-digits',
//     'unflag-result-digits',
//     'cleanup'
// ]);

function render() {
  // const digits = F.filter(s => s === "0" || s === "1").join("") || "—";
  const digits = tape.filter(s => s === "0" || s === "1").join("") || "—";
  document.getElementById("state").textContent = state + (sub_state > 0 ? ` (step ${sub_state})` : "");
  document.getElementById("head").textContent = String(head);
  document.getElementById("digits").textContent = digits;

  const interleavedRow = document.getElementById("interleaved");
  interleavedRow.innerHTML = "";

  // const maxLen = Math.max(F.length, E.length, 30);
  const maxLen = Math.max(tape.length, 30);
  // while (F.length < maxLen) F.push(BLANK);
  // while (E.length < maxLen) E.push(BLANK);
  while (tape.length < maxLen) tape.push(BLANK);

  // const activeTape = E_TAPE_STATES.has(state) ? 'E' : 'F';

  for (let i = 0; i < maxLen; i++) {
    if (i % 2 === 1) {
      const cf = document.createElement("div");
      cf.className = "cell f" + (i === head ? " head" : "");
      const f = tape[i] ?? BLANK;
      cf.innerHTML = `<span class="idx">F${i}</span><span class="${symbolClass(f)}">${f === BLANK ? "·" : f}</span>`;
      interleavedRow.appendChild(cf);
    } else {
      const ce = document.createElement("div");
      ce.className = "cell e" + (i === head ? " head" : "");
      const e = tape[i] ?? BLANK;
      ce.innerHTML = `<span class="idx">E${i}</span><span class="${symbolClass(e)}">${e === BLANK ? "·" : e}</span>`;
      interleavedRow.appendChild(ce);
    }

    // const cf = document.createElement("div");
    // // cf.className = "cell f" + (i === head && activeTape === 'F' ? " head" : "");
    // cf.className = "cell f" + (i === head && i % 2 === 1 ? " head" : "");
    // // const f = F[i] ?? BLANK;
    // const f = tape[i] ?? BLANK;
    // cf.innerHTML = `<span class="idx">F${i}</span><span class="${symbolClass(f)}">${f === BLANK ? "·" : f}</span>`;
    // interleavedRow.appendChild(cf);

    // const ce = document.createElement("div");
    // // ce.className = "cell e" + (i === head && activeTape === 'E' ? " head" : "");
    // ce.className = "cell e" + (i === head && i % 2 === 0 ? " head" : "");
    // // const e = E[i] ?? BLANK;
    // const e = tape[i] ?? BLANK;
    // ce.innerHTML = `<span class="idx">E${i}</span><span class="${symbolClass(e)}">${e === BLANK ? "·" : e}</span>`;
    // interleavedRow.appendChild(ce);
  }
}

/*** Logging & Controls ***/
const logEl = document.getElementById("log");
function log(msg) {
  const div = document.createElement("div");
  div.className = "entry";
  div.textContent = `[${stepCount}] ${state}: ${msg}`;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}
function logClear() { logEl.innerHTML = ""; }
function setMsg(s)  { document.getElementById("msg").textContent = s; }
initialize();

/*** Tape Operations ***/
// function readF() { return F[head] ?? BLANK; }
// function readE() { return E[head] ?? BLANK; }
function read() { return tape[head] ?? BLANK; }
// function writeF(sym) { F[head] = sym; }
// function writeE(sym) { E[head] = sym; }
function write(sym) { tape[head] = sym; }
function moveL() { head = Math.max(0, head-1); }
function moveR() {
  head += 1;
  // if (head >= F.length) { F.push(BLANK); E.push(BLANK); }
  if (head >= tape.length) { tape.push(BLANK); }
}

function changeState(newState) {
    if (state !== newState) {
        log(`→ transitioning to state: ${newState}`);
        state = newState;
        sub_state = 0;
    }
}

// update Needed: we should be rendering the state after each subprocess so we can see the head move one step at a time, rather than after each m-config. state change
/*** Main Machine Step Function ***/
function step() {
  if (state === "halt") { setMsg("HALT"); return; }
  stepCount++;
  setMsg("");

  // Dispatch to the function for the current m-configuration
  switch (state) {
    case "begin": st_begin(); break;
    case "new": st_new(); break;
    case "mark-digits": st_mark_digits(); break;
    case "find-x": st_find_x(); break;
    case "first-r": st_first_r(); break;
    case "last-r": st_last_r(); break;
    case "find-digits": st_find_digits(); break;
    case "find-1st-digit": st_find_1st_digit(); break;
    case "found-1st-digit": st_found_1st_digit(); break;
    case "find-2nd-digit": st_find_2nd_digit(); break;
    case "found-2nd-digit": st_found_2nd_digit(); break;
    case "add-zero": st_add_zero(); break;
    case "add-one": st_add_one(); break;
    case "carry": st_carry(); break;
    case "add-finished": st_add_finished(); break;
    case "erase-old-x": st_erase_old_x(); break;
    case "print-new-x": st_print_new_x(); break;
    case "erase-old-y": st_erase_old_y(); break;
    case "print-new-y": st_print_new_y(); break;
    case "reset-new-x": st_reset_new_x(); break;
    case "flag-result-digits": st_flag_result_digits(); break;
    case "unflag-result-digits": st_unflag_result_digits(); break;
    case "new-digit-is-zero": st_new_digit_is_zero(); break;
    case "print-zero-digit": st_print_zero_digit(); break;
    case "new-digit-is-one": st_new_digit_is_one(); break;
    case "print-one-digit": st_print_one_digit(); break;
    case "cleanup": st_cleanup(); break;
    default:
      setMsg("Unknown state: "+state);
      changeState("halt");
      break;
  }
  
  render();
}

/*** M-Configuration (State) Functions ***/

// m-config | symbol | operations | final m-config
// begin | none | P@, R, P1 | new
function st_begin() {
    switch(sub_state) {
        case 0:
            log("Initial setup: P@");
            write(SENTINEL);
            sub_state++;
            break;
        case 1:
            log("Initial setup: R");
            moveR();
            sub_state++;
            break;
        case 2:
            log("Initial setup: P1");
            write("1");
            sub_state++;
            break;
        case 3:
            changeState("new");
            break;
    }
}

// m-config | symbol | operations | final m-config
// new | @ | R | mark-digits
// new | else | L | new
function st_new() {
  switch(read()) {
    case SENTINEL:
      log("read @, moving R");
      moveR();
      changeState("mark-digits");
      break;
    default:
      log("read non-@, moving L");
      moveL();
      break;
  }
}

// m-config | symbol | operations | final m-config
// mark-digits| 0 or 1 | R, Px, R | mark-digits
// mark-digits| none | R, Pz, R, R, Pr | find-x
function st_mark_digits() {
    const sym = read();
    if (sym === '0' || sym === '1') {
        switch(sub_state) {
            case 0:
                log(`read F='${sym}', moving R`);
                moveR();
                sub_state++;
                break;
            case 1:
                log(`writing 'x'`);
                write('x');
                sub_state++;
                break;
            case 2:
                log(`moving R`);
                moveR();
                sub_state = 0;
                break;
        }
    } else if (sym === BLANK) {
        switch(sub_state) {
            case 0:
                log(`read BLANK, moving R`);
                moveR();
                sub_state++;
                break;
            case 1:
                log(`writing 'z' to E`);
                write('z');
                sub_state++;
                break;
            case 2:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 3:
                log(`moving R`);
                moveR();
                sub_state++;
                break;
            case 4:
                log(`writing 'r' to E`);
                write('r');
                sub_state++;
                break;
            case 5:
                changeState('find-x');
                break;
        }
    } else {
        // If we read something else, like '@', it means we're done marking leftward
        changeState('find-x');
    }
}


// m-config | symbol | operations | final m-config
// find-x | x | E | first-r
// find-x | @ | N | find-digits
// find-x | else | L, L | find-x
function st_find_x() {
  const symE = read();
  const symF = read();

  if (sub_state === 0) {
    log(`read E='${symE}', F='${symF}'`);
    if (symE === 'x') {
        write(BLANK); // E operation
        changeState('first-r');
    } else if (symF === SENTINEL) {
        changeState('find-digits'); // N operation
    } else {
        moveL(); // First L
        sub_state++;
    }
  } else {
      moveL(); // Second L
      sub_state = 0; // Reset for next cycle
  }
}

// m-config | symbol | operations | final m-config
// first-r | r | R, R | last-r
// first-r | else | R, R | first-r
function st_first_r() {
    const sym = read();
    if (sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log(`moving R again`);
        moveR();
        if (sym === 'r') {
            changeState('last-r');
        } else {
            sub_state = 0; // Stay in first-r
        }
    }
}

// m-config | symbol | operations | final m-config
// last-r | r | R, R | last-r
// last-r | none | Pr, R, R, Pr | find-x
function st_last_r() {
    const sym = read();
    if (sym === BLANK) {
        switch(sub_state) {
            case 0:
                log(`read BLANK, writing 'r'`);
                write('r');
                sub_state++;
                break;
            case 1:
                log('moving R');
                moveR();
                sub_state++;
                break;
            case 2:
                 log('moving R');
                moveR();
                sub_state++;
                break;
            case 3:
                log(`writing 'r'`);
                write('r');
                sub_state++;
                break;
            case 4:
                changeState('find-x');
                break;
        }
    } else {
        if (sub_state === 0) {
            log(`read E='${sym}', moving R`);
            moveR();
            sub_state++;
        } else {
            log('moving R again');
            moveR();
            sub_state = 0; // Reset for next cycle
        }
    }
}

// m-config | symbol | operations | final m-config
// find-digits | @ | R, R | find-1st-digit
// find-digits | else | L, L | find-digits
function st_find_digits() {
  const sym = read();
  // update Needed: the sub_state is incremented but the symbol shouldn't be read the second time
  if (sym === SENTINEL) {
      // if(sub_state === 0) {
      //     log(`read @, moving R`);
      //     moveR();
      //     sub_state++;
      // } else {
      //     log(`moving R again`);
      //     moveR();
      //     changeState('find-1st-digit');
      // }
      if(sub_state === 0) {
          log(`read @, moving R`);
          moveR();
          sub_state++;
          log(`moving R again`);
          moveR();
          changeState('find-1st-digit');
      }
  } else {
      if(sub_state === 0) {
          log(`read non-@, moving L`);
          moveL();
          sub_state++;
          log(`moving L again`);
          moveL();
          // sub_state = 0;
          changeState('find-digits');
      }
  }
}

// m-config | symbol | operations | final m-config
// find-1st-digit | x/y/z | L | ...
// find-1st-digit | none | R, R | find-1st-digit
function st_find_1st_digit() {
  const sym = read();
  switch(sym) {
    case 'x':
    case 'y':
      log(`read E='${sym}', moving L`);
      moveL();
      changeState('found-1st-digit');
      break;
    case 'z':
      log(`read E='${sym}', moving L`);
      moveL();
      changeState('found-2nd-digit');
      break;
    default: // Covers BLANK ('none') and other symbols
      if(sub_state === 0) {
          log(`read E='${sym}', moving R`);
          moveR();
          sub_state++;
      } else {
          log(`moving R again`);
          moveR();
          sub_state = 0;
      }
      break;
  }
}

// m-config | symbol | operations | final m-config
// found-1st-digit | 0 | R | add-zero
// found-1st-digit | 1 | R, R, R | find-2nd-digit
function st_found_1st_digit() {
  const sym = read();
  if (sym === '0') {
    log(`read F='${sym}', moving R`);
    moveR();
    changeState('add-zero');
  } else if (sym === '1') {
      switch(sub_state) {
          case 0:
              log(`read F='${sym}', moving R`);
              moveR();
              sub_state++;
              break;
          case 1:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 2:
              log(`moving R`);
              moveR();
              sub_state++;
              break;
          case 3:
              changeState('find-2nd-digit');
              break;
      }
  }
}

// m-config | symbol | operations | final m-config
// find-2nd-digit | x/y | L | found-2nd-digit
// find-2nd-digit | none | R, R | find-2nd-digit
function st_find_2nd_digit() {
  const sym = read();
  if (sym === 'x' || sym === 'y') {
    log(`read E='${sym}', moving L`);
    moveL();
    changeState('found-2nd-digit');
  } else {
    if(sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log(`moving R again`);
        moveR();
        sub_state=0;
    }
  }
}

// m-config | symbol | operations | final m-config
// found-2nd-digit | 0 | R | add-zero
// found-2nd-digit | 1/none | R | add-one
function st_found_2nd_digit() {
  const sym = read();
  log(`read F='${sym}', moving R`);
  moveR();
  if (sym === '0') {
    changeState('add-zero');
  } else { // Covers '1' and BLANK ('none'), both add 1
    changeState('add-one');
  }
}

// m-config | symbol | operations | final m-config
// add-zero | r/u | Ps/Pv | add-finished
// add-zero | else | R, R | add-zero
function st_add_zero() {
  const sym = read();
  if (sym === 'r') {
    log(`read E='${sym}', writing 's'`);
    write('s');
    changeState('add-finished');
  } else if (sym === 'u') {
    log(`read E='${sym}', writing 'v'`);
    write('v');
    changeState('add-finished');
  } else {
    if(sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log(`moving R again`);
        moveR();
        sub_state=0;
    }
  }
}

// m-config | symbol | operations | final m-config
// add-one | r | Pv | add-finished
// add-one | u | Ps, R, R | carry
// add-one | else | R, R | add-one
function st_add_one() {
  const sym = read();
  if (sym === 'r') {
    log(`read E='${sym}', writing 'v'`);
    write('v');
    changeState('add-finished');
  } else if (sym === 'u') {
    if(sub_state === 0) {
        log(`read E='${sym}', writing 's'`);
        write('s');
        sub_state++;
    } else if (sub_state === 1) {
        log('moving R');
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        changeState('carry');
    }
  } else {
    if(sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        sub_state=0;
    }
  }
}

// m-config | symbol | operations | final m-config
// carry | r/none | Pu | ...
// carry | u | Pr, R, R | carry
function st_carry() {
  const sym = read();
  if (sym === 'r') {
    log(`read E='${sym}', writing 'u'`);
    write('u');
    changeState('add-finished');
  } else if (sym === BLANK) {
    log(`read BLANK, writing 'u'`);
    write('u');
    changeState('new-digit-is-zero');
  } else if (sym === 'u') {
      if(sub_state === 0) {
        log(`read E='${sym}', writing 'r'`);
        write('r');
        sub_state++;
      } else if (sub_state === 1) {
        log('moving R');
        moveR();
        sub_state++;
      } else {
        log('moving R again');
        moveR();
        sub_state = 0; // Stay in carry
      }
  } else {
      // Book doesn't specify but implies keep moving
      log(`read E='${sym}', moving R`);
      moveR();
  }
}

// m-config | symbol | operations | final m-config
// add-finished | @ | R, R | erase-old-x
// add-finished | else | L, L | add-finished
function st_add_finished() {
  const sym = read();
  if (sym === SENTINEL) {
    if(sub_state === 0) {
        log(`read @, moving R`);
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        changeState('erase-old-x');
    }
  } else {
    if(sub_state === 0) {
        log(`read non-@, moving L`);
        moveL();
        sub_state++;
    } else {
        log('moving L again');
        moveL();
        sub_state=0;
    }
  }
}

// m-config | symbol | operations | final m-config
// erase-old-x | x | E, L, L | print-new-x
// erase-old-x | z | Py, L, L | print-new-x
// erase-old-x | else | R, R | erase-old-x
function st_erase_old_x() {
  const sym = read();
  const opSequence = (writeSym) => {
      switch(sub_state) {
          case 0:
              log(`read E='${sym}', writing '${writeSym}'`);
              write(writeSym);
              sub_state++;
              break;
          case 1:
              log('moving L');
              moveL();
              sub_state++;
              break;
          case 2:
              log('moving L again');
              moveL();
              changeState('print-new-x');
              break;
      }
  };

  if (sym === 'x') {
      opSequence(BLANK);
  } else if (sym === 'z') {
      opSequence('y');
  } else {
    if(sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        sub_state=0;
    }
  }
}

// m-config | symbol | operations | final m-config
// print-new-x | @ | R, R | erase-old-y
// print-new-x | y | Pz | find-digits
// print-new-x | none | Px | find-digits
function st_print_new_x() {
  const symF = read();
  const symE = read();
  log(`read F='${symF}', E='${symE}'`);
  if (symF === SENTINEL) {
    if(sub_state === 0) {
        log(`read @, moving R`);
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        changeState('erase-old-y');
    }
  } else if (symE === 'y') {
    log(`writing 'z'`);
    write('z');
    changeState('find-digits');
  } else if (symE === BLANK) {
    log(`writing 'x'`);
    write('x');
    changeState('find-digits');
  } else {
      log('Error in print-new-x logic, moving R');
      moveR();
  }
}

// m-config | symbol | operations | final m-config
// erase-old-y | y | E, L, L | print-new-y
// erase-old-y | else | R, R | erase-old-y
function st_erase_old_y() {
    const sym = read();
    if(sym === 'y') {
        switch(sub_state) {
            case 0:
                log(`read E='${sym}', erasing`);
                write(BLANK);
                sub_state++;
                break;
            case 1:
                log('moving L');
                moveL();
                sub_state++;
                break;
            case 2:
                log('moving L again');
                moveL();
                changeState('print-new-y');
                break;
        }
    } else {
        if(sub_state === 0) {
            log(`read E='${sym}', moving R`);
            moveR();
            sub_state++;
        } else {
            log('moving R again');
            moveR();
            sub_state = 0;
        }
    }
}


// m-config | symbol | operations | final m-config
// print-new-y | @ | R | new-digit-is-one
// print-new-y | else | Py, R | reset-new-x
function st_print_new_y() {
  const sym = read();
  if (sym === SENTINEL) {
    log(`read @, moving R`);
    moveR();
    changeState('new-digit-is-one');
  } else {
    if(sub_state === 0) {
        log(`read F='${sym}', writing 'y'`);
        write('y');
        sub_state++;
    } else {
        log('moving R');
        moveR();
        changeState('reset-new-x');
    }
  }
}

// m-config | symbol | operations | final m-config
// reset-new-x | none | R, Px | flag-result-digits
// reset-new-x | else | R, R | reset-new-x
function st_reset_new_x() {
  const sym = read();
  if (sym === BLANK) {
      if(sub_state === 0) {
        log(`read BLANK, moving R`);
        moveR();
        sub_state++;
      } else {
        log(`writing 'x'`);
        write('x');
        changeState('flag-result-digits');
      }
  } else {
    if(sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        sub_state = 0;
    }
  }
}

// m-config | symbol | operations | final m-config
// flag-result-digits | s | Pt, R, R | unflag-result-digits
// flag-result-digits | v | Pw, R, R | unflag-result-digits
// flag-result-digits | else | R, R | flag-result-digits
function st_flag_result_digits() {
  const sym = read();
  const opSequence = (writeSym) => {
      switch(sub_state) {
          case 0:
            log(`read E='${sym}', writing '${writeSym}'`);
            write(writeSym);
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            changeState('unflag-result-digits');
            break;
      }
  };

  if (sym === 's') {
    opSequence('t');
  } else if (sym === 'v') {
    opSequence('w');
  } else {
    if(sub_state === 0) {
        log(`read E='${sym}', moving R`);
        moveR();
        sub_state++;
    } else {
        log('moving R again');
        moveR();
        sub_state = 0;
    }
  }
}

// m-config | symbol | operations | final m-config
// unflag-result-digits | s | Pr, R, R | unflag-result-digits
// unflag-result-digits | v | Pu, R, R | unflag-result-digits
// unflag-result-digits | else | N | find-digits
function st_unflag_result_digits() {
    const sym = read();
    const opSequence = (writeSym) => {
        switch(sub_state) {
            case 0:
                log(`read E='${sym}', writing '${writeSym}'`);
                write(writeSym);
                sub_state++;
                break;
            case 1:
                log('moving R');
                moveR();
                sub_state++;
                break;
            case 2:
                log('moving R again');
                moveR();
                sub_state = 0; // stay in state
                break;
        }
    };
    if (sym === 's') {
        opSequence('r');
    } else if (sym === 'v') {
        opSequence('u');
    } else {
        changeState('find-digits');
    }
}

// m-config | symbol | operations | final m-config
// new-digit-is-zero | @ | R | print-zero-digit
// new-digit-is-zero | else | L | new-digit-is-zero
function st_new_digit_is_zero() {
  const sym = read();
  if (sym === SENTINEL) {
    log(`read @, moving R`);
    moveR();
    changeState('print-zero-digit');
  } else {
    log(`read non-@, moving L`);
    moveL();
  }
}

// m-config | symbol | operations | final m-config
// print-zero-digit | 0/1 | R, E, R | print-zero-digit
// print-zero-digit | none | P0, R, R | cleanup
function st_print_zero_digit() {
  const sym = read();
  if (sym === '0' || sym === '1') {
      switch(sub_state) {
          case 0:
            log(`read F='${sym}', moving R`);
            moveR();
            sub_state++;
            break;
          case 1:
            log('erasing marker on E');
            write(BLANK);
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state = 0;
            break;
      }
  } else if (sym === BLANK) {
      switch(sub_state) {
          case 0:
            log(`read BLANK, writing '0'`);
            write('0');
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            changeState('cleanup');
            break;
      }
  }
}

// m-config | symbol | operations | final m-config
// new-digit-is-one | @ | R | print-one-digit
// new-digit-is-one | else | L | new-digit-is-one
function st_new_digit_is_one() {
  const sym = read();
  if (sym === SENTINEL) {
    log(`read @, moving R`);
    moveR();
    changeState('print-one-digit');
  } else {
    log(`read non-@, moving L`);
    moveL();
  }
}

// m-config | symbol | operations | final m-config
// print-one-digit | 0/1 | R, E, R | print-one-digit
// print-one-digit | none | P1, R, R | cleanup
function st_print_one_digit() {
  const sym = read();
  if (sym === '0' || sym === '1') {
      switch(sub_state) {
          case 0:
            log(`read F='${sym}', moving R`);
            moveR();
            sub_state++;
            break;
          case 1:
            log('erasing marker on E');
            write(BLANK);
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            sub_state = 0;
            break;
      }
  } else if (sym === BLANK) {
      switch(sub_state) {
          case 0:
            log(`read BLANK, writing '1'`);
            write('1');
            sub_state++;
            break;
          case 1:
            log('moving R');
            moveR();
            sub_state++;
            break;
          case 2:
            log('moving R again');
            moveR();
            changeState('cleanup');
            break;
      }
  }
}

// m-config | symbol | operations | final m-config
// cleanup | none | N | new
// cleanup | else | E, R, R | cleanup
function st_cleanup() {
    const sym = read();
    if (sym === BLANK) {
        let markerFound = false;
        for(let i = head; i < E.length; i++) {
            // Check for any non-blank, non-running-total symbol
            if(E[i] !== BLANK && !RT0.has(E[i]) && !RT1.has(E[i])) { 
                markerFound = true;
                break;
            }
        }
        if (markerFound) {
            log('found other markers, moving R to continue cleanup');
            moveR();
        } else {
           log('no more markers, cleanup complete');
           changeState('new');
        }
    } else {
        // Erase only markers (x,y,z), not running total symbols
        if (!RT0.has(sym) && !RT1.has(sym)) {
            log(`read E='${sym}', erasing marker`);
            write(BLANK);
        }
        log(`moving R`);
        moveR();
    }
}


/*** UI Controls ***/
document.getElementById("btnStep").addEventListener("click", ()=> {
  if (!running) { step(); }
});
document.getElementById("btnRun").addEventListener("click", ()=> {
  if (running) return;
  running = true;
  const speedSel = document.getElementById("speed");
  const delay = parseInt(speedSel.value, 10);
  timer = setInterval(()=> {
    if (running) step();
    else clearInterval(timer);
  }, delay);
});
document.getElementById("btnPause").addEventListener("click", ()=> {
  running = false;
  clearInterval(timer);
});
document.getElementById("btnReset").addEventListener("click", ()=> {
  running = false;
  clearInterval(timer);
  initialize();
});
</script>
</body>
</html>

