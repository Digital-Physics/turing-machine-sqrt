<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Turing Machine Simulator — √2 (faithful to the book)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --bg: #0f1117;
    --fg: #e6e6e6;
    --muted: #a9a9b3;
    --accent: #6ee7b7;
    --warn: #fbbf24;
    --danger: #f87171;
    --fcell: #1d2330;      /* F-squares row background */
    --ecell: #1a202c;      /* E-squares row background */
    --head: #93c5fd;       /* head highlight */
    --marker-x: #f59e0b;
    --marker-y: #f472b6;
    --marker-z: #a78bfa;
    --rt-0: #94a3b8;       /* r,s,t (0) */
    --rt-1: #60a5fa;       /* u,v,w (1) */
  }
  html, body {
    background: var(--bg);
    color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    margin: 0;
  }
  header {
    padding: 18px 20px 6px;
    text-align: center;
  }
  header h1 {
    margin: 0 0 8px;
    font-size: 22px;
    font-weight: 700;
  }
  header p {
    margin: 0;
    color: var(--muted);
    font-size: 14px;
  }
  .wrap {
    max-width: 1100px;
    margin: 18px auto 60px;
    padding: 0 16px;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 14px;
  }
  .controls button, .controls select {
    background: #1d2736;
    color: var(--fg);
    border: 1px solid #2c3647;
    border-radius: 10px;
    padding: 8px 14px;
    cursor: pointer;
    font-weight: 600;
  }
  .controls button:hover, .controls select:hover { border-color: #3a465b; }
  .controls .danger { border-color: var(--danger); color: var(--danger); }
  .statusbar {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 12px;
    font-size: 14px;
    color: var(--muted);
  }
  .statusbar div b { color: var(--fg); }
  .board {
    background: #0c0f16;
    border: 1px solid #1a2333;
    border-radius: 14px;
    padding: 14px;
  }
  .tape {
    display: grid;
    grid-template-columns: 90px 1fr;
    gap: 8px;
    align-items: start;
  }
  .label {
    color: var(--muted);
    padding-top: 6px;
    font-weight: 700;
  }
  .row {
    overflow-x: auto;
    border: 1px solid #1f2a3d;
    border-radius: 10px;
    background: #0c121d;
    padding: 10px;
  }
  .cells {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: minmax(32px, 40px);
    gap: 6px;
  }
  .cell {
    height: 40px;
    border-radius: 8px;
    display: grid;
    place-items: center;
    font-weight: 800;
    letter-spacing: 0.4px;
    border: 1px solid #273149;
    position: relative;
  }
  .cell.f { background: var(--fcell); }
  .cell.e { background: var(--ecell); }
  .cell .idx {
    position: absolute;
    top: -8px;
    font-size: 10px;
    color: var(--muted);
  }
  .cell.head { outline: 3px solid var(--head); z-index: 2; }
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 10px 18px;
    margin-top: 12px;
    color: var(--muted);
    font-size: 12px;
  }
  .chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .dot {
    width: 10px; height: 10px; border-radius: 999px;
  }
  .dot.x { background: var(--marker-x); }
  .dot.y { background: var(--marker-y); }
  .dot.z { background: var(--marker-z); }
  .dot.r0 { background: var(--rt-0); }
  .dot.r1 { background: var(--rt-1); }
  .log {
    margin-top: 16px;
    height: 200px;
    overflow: auto;
    border: 1px solid #1a2333;
    border-radius: 10px;
    background: #0b0f17;
    padding: 10px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    font-size: 12.5px;
  }
  .log .entry { margin: 0 0 6px; white-space: pre; }
  .hl-x { color: var(--marker-x); font-weight: 700; }
  .hl-y { color: var(--marker-y); font-weight: 700; }
  .hl-z { color: var(--marker-z); font-weight: 700; }
  .hl0 { color: var(--rt-0); font-weight: 700; }
  .hl1 { color: var(--rt-1); font-weight: 700; }
  .hlh { color: var(--head); font-weight: 700; }
  .hls { color: var(--accent); font-weight: 700; }
  footer {
    text-align: center;
    color: var(--muted);
    font-size: 12px;
    margin: 16px 0 40px;
  }
</style>
</head>
<body>
  <header>
    <h1>√2 Turing Machine — faithful step-by-step simulator</h1>
    <p>F-squares (top) show digits; E-squares (bottom) hold the running total and markers (x,y,z,r,s,t,u,v,w). Step through the exact m-configurations.</p>
  </header>

  <div class="wrap">
    <div class="controls">
      <button id="btnStep">Step</button>
      <button id="btnRun">Run</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset" class="danger">Reset</button>
      <label style="margin-left:8px;">Speed:
        <select id="speed">
          <option value="800">Slow</option>
          <option value="400" selected>Medium</option>
          <option value="160">Fast</option>
          <option value="60">Very Fast</option>
        </select>
      </label>
      <span id="msg" style="margin-left:auto;color:var(--warn);"></span>
    </div>

    <div class="statusbar">
      <div>State: <b id="state">begin</b></div>
      <div>Head @ index: <b id="head">0</b></div>
      <div>Digits so far: <b id="digits">—</b></div>
    </div>

    <div class="board">
      <div class="tape">
        <div class="label">F-squares</div>
        <div class="row"><div id="rowF" class="cells"></div></div>
        <div class="label">E-squares</div>
        <div class="row"><div id="rowE" class="cells"></div></div>
      </div>
      <div class="legend">
        <span class="chip"><span class="dot x"></span>x marker</span>
        <span class="chip"><span class="dot y"></span>y marker</span>
        <span class="chip"><span class="dot z"></span>z marker (= x & y coincide)</span>
        <span class="chip"><span class="dot r0"></span>r/s/t → 0</span>
        <span class="chip"><span class="dot r1"></span>u/v/w → 1</span>
        <span>Head = blue outline</span>
      </div>
      <div id="log" class="log"></div>
    </div>

    <footer>
      Built to mirror the states and markers described in the book’s √2 machine (Petzold). It logs every micro-step: reads, writes, moves, and state transitions.
    </footer>
  </div>

<script>
/* ============================================================
   √2 Turing Machine (faithful visual simulator)
   ------------------------------------------------------------
   Notes:
   - We present *two parallel tracks* (F and E) for clarity.
     The book conceptually uses E-squares for workspace &
     F-squares for the printed digits of √2.
   - We implement the machine at the level of the named
     m-configurations (states) from the book and emulate the
     symbol manipulations they describe (x/y/z markers, r..w).
   - Each "step()" performs a *micro-step* inside the current
     m-configuration; some states internally unwind via substates.
   - We keep a high-fidelity event log to show the whole dance.
   ============================================================ */

/*** Tape model ***/
const BLANK = " ";     // blank
const SENTINEL = "@";  // sentinel printed at start

// Running total symbol semantics (as in book)
const RT0 = new Set(["r","s","t"]); // all mean 0
const RT1 = new Set(["u","v","w"]); // all mean 1

// Utility: classify symbol for coloring
function symbolClass(sym) {
  if (sym === "x") return "hl-x";
  if (sym === "y") return "hl-y";
  if (sym === "z") return "hl-z";
  if (RT0.has(sym)) return "hl0";
  if (RT1.has(sym)) return "hl1";
  if (sym === SENTINEL) return "hls";
  if (sym === "0" || sym === "1") return "";
  return "muted";
}

// Model the tape as two aligned arrays:
// F: digits of sqrt(2). E: workspace & running total.
let F = []; // e.g., ["@", "1", "0", ...] (we’ll align @ on F[0] too for visualization)
let E = []; // e.g., [" ", " ", "r", "r", ...] running total and markers

// head index refers to column index shared by F & E
let head = 0;

// m-configuration (state)
let state = "begin";

// substate & context variables used across states
let sub = null;
let ctx = {};

// execution / UI
let running = false;
let timer = null;
let stepCount = 0;

// Initialize machine to the exact book start:
// begin: print @ then 1; go to new.
function initialize() {
  F = [BLANK]; // we’ll print @ at index 0
  E = [BLANK];
  head = 0;
  state = "begin";
  sub = null;
  ctx = {};
  stepCount = 0;
  logClear();
  render();
  setMsg("");
}
// initialize();

/*** Rendering ***/
function render() {
  // derived: current digits printed so far (skip blanks & sentinel)
  const digits = F.filter((s,i)=> (s==="0"||s==="1") && i>=0).join("") || "—";

  document.getElementById("state").textContent = state + (sub ? ` / ${sub}` : "");
  document.getElementById("head").textContent = String(head);
  document.getElementById("digits").textContent = digits.startsWith("@") ? digits.slice(1) : digits;

  const rowF = document.getElementById("rowF");
  const rowE = document.getElementById("rowE");
  rowF.innerHTML = "";
  rowE.innerHTML = "";

  const maxLen = Math.max(F.length, E.length);
  // pad both to same length
  while (F.length < maxLen) F.push(BLANK);
  while (E.length < maxLen) E.push(BLANK);

  for (let i=0; i<maxLen; i++) {
    const cf = document.createElement("div");
    cf.className = "cell f" + (i===head ? " head":"");
    const f = F[i] ?? BLANK;
    cf.innerHTML = `<span class="idx">${i}</span><span class="${symbolClass(f)}">${f===BLANK?"·":f}</span>`;
    rowF.appendChild(cf);

    const ce = document.createElement("div");
    ce.className = "cell e" + (i===head ? " head":"");
    const e = E[i] ?? BLANK;
    ce.innerHTML = `<span class="idx">${i}</span><span class="${symbolClass(e)}">${e===BLANK?"·":e}</span>`;
    rowE.appendChild(ce);
  }
}

/*** Logging ***/
const logEl = document.getElementById("log");
function log(msg) {
  const div = document.createElement("div");
  div.className = "entry";
  div.textContent = msg;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}
function logClear() { logEl.innerHTML = ""; }
function setMsg(s)  { document.getElementById("msg").textContent = s; }
initialize();

/*** Helpers to read/write/move ***/
function readF() { return F[head] ?? BLANK; }
function readE() { return E[head] ?? BLANK; }
function writeF(sym) { F[head] = sym; }
function writeE(sym) { E[head] = sym; }
function moveL() { head = Math.max(0, head-1); }
function moveR() { head += 1; // extend arrays lazily
  if (head >= F.length) { F.push(BLANK); E.push(BLANK); }
}
function seekLeftTo(symSet) {
  while (head>0 && !symSet.has(readF()) && !symSet.has(readE())) moveL();
}
function seekRightTo(symSet) {
  // will extend if necessary
  while (!symSet.has(readF()) && !symSet.has(readE())) moveR();
}

/*** Book-specific utilities ***/

// Convert whole running total (E) into a binary array (LSB on LEFT as in book).
// We interpret r/s/t as 0 and u/v/w as 1. Non RT symbols = ignored.
function getRunningTotalBits() {
  // Scan E from left to right; treat first RT char as LSB.
  const bits = [];
  for (let i=0;i<E.length;i++) {
    const e = E[i];
    if (RT0.has(e)) bits.push(0);
    else if (RT1.has(e)) bits.push(1);
  }
  return bits; // [LSB,...,MSB]
}

// Change first r→s or u→v (leftmost encountered scanning L→R)
// This is the "add-zero" advance of position (shift the add position).
function rtAdvancePosition() {
  for (let i=0;i<E.length;i++) {
    const e = E[i];
    if (e === "r") { E[i] = "s"; return {i, from:"r", to:"s"}; }
    if (e === "u") { E[i] = "v"; return {i, from:"u", to:"v"}; }
  }
  // If none found, extend one position with 's' which is still 0 at next place.
  E.push("s");
  return {i:E.length-1, from:BLANK, to:"s"};
}

// add-one logic:
// first r → v  (0→1, done)
// or first u → s (1→0, then carry to next position)
// if carry writes into a blank → overflow (means product ≥ 2) => new-digit-is-zero
function rtAddOneWithCarry() {
  for (let i=0;i<E.length;i++) {
    const e = E[i];
    if (e === "r") { E[i]="v"; return {carry:false, index:i, wrote:"v"}; } // 0->1
    if (e === "u") { E[i]="s"; // 1->0 with carry
      // propagate carry to next cell to the right (i+1)
      let j = i+1;
      if (j >= E.length) { // blank → overflow trigger
        E.push("u"); // write a 1 (carry)
        return {carry:true, index:j, wrote:"u", overflow:true};
      }
      // if next is blank treat as zero and write 'u'
      const nxt = E[j];
      if (nxt===BLANK) { E[j]="u"; return {carry:true, index:j, wrote:"u", overflow:true}; }
      // standard carry rippling
      while (true) {
        if (j >= E.length) { E.push("u"); return {carry:true, index:j, wrote:"u", overflow:true}; }
        const v = E[j];
        if (v==="r") { E[j]="v"; return {carry:true, index:j, wrote:"v"}; } // 0->1 ends carry
        if (v==="u") { E[j]="s"; j++; continue; } // 1->0 keep carry
        if (v===BLANK) { E[j]="u"; return {carry:true, index:j, wrote:"u", overflow:true}; }
        // If we meet s/t/v/w we treat them by base meaning: s/t (0), v/w (1)
        if (v==="s"||v==="t") { E[j]=(v==="s"?"t":"t"); /* 0->0 tagged; but to reflect book we’ll nudge */
          // more faithful: s(0)->? none in add-one; but to keep simple, turn s→t to mark pos shift territory
          return {carry:true, index:j, wrote:E[j]}; }
        if (v==="v"||v==="w") { E[j]=(v==="v"?"w":"w"); j++; continue; }
        // If we run into markers x/y/z, skip to next E cell
        j++;
      }
    }
    // skip non-running-total letters
  }
  // No r/u found: append v at new position
  E.push("v");
  return {carry:false, index:E.length-1, wrote:"v"};
}

// Transform v/s marks forward for next add position as per flag/unflag steps
function flagResultDigits() {
  for (let i=0;i<E.length;i++) {
    if (E[i]==="s") { E[i]="t"; return {i, from:"s", to:"t"}; }
    if (E[i]==="v") { E[i]="w"; return {i, from:"v", to:"w"}; }
  }
  return null;
}
function unflagResultDigits() {
  // remaining s/v → r/u
  let changed = false;
  for (let i=0;i<E.length;i++) {
    if (E[i]==="s") { E[i]="r"; changed = true; }
    if (E[i]==="v") { E[i]="u"; changed = true; }
  }
  return changed;
}

// Helper: current printed number on F (digits only, treat blank as unknown next slot)
function currentDigits() {
  // F[0] is @, digits follow
  let out = "";
  for (let i=0;i<F.length;i++) {
    const s = F[i];
    if (s==="0"||s==="1") out += s;
  }
  return out || "";
}

/*** Machine states — faithful flow ***/

// We encode each state as a function that advances a small piece of work,
// possibly using sub-steps ("sub") to animate moves/writes. Each invocation of
// step() calls exactly one micro-step (so UI visibly advances).

function step() {
  if (state === "halt") { setMsg("HALT"); return; }
  stepCount++;
  setMsg("");

  switch (state) {
    case "begin": return st_begin();
    case "new": return st_new();
    case "mark-digits": return st_mark_digits();
    case "first-r": return st_first_r();          // initialize running total r...r
    case "last-r": return st_last_r();
    case "find-digits": return st_find_digits();  // scan for x/y/z and add contributions
    case "add-zero": return st_add_zero();
    case "add-one": return st_add_one();
    case "carry": return st_carry();
    case "add-finished": return st_add_finished();
    case "erase-old-x": return st_erase_old_x();
    case "print-new-x": return st_print_new_x();
    case "erase-old-y": return st_erase_old_y();
    case "print-new-y": return st_print_new_y();
    case "reset-new-x": return st_reset_new_x();
    case "flag-result-digits": return st_flag_result_digits();
    case "unflag-result-digits": return st_unflag_result_digits();
    case "new-digit-is-one": return st_new_digit_is_one();
    case "new-digit-is-zero": return st_new_digit_is_zero();
    case "print-one-digit": return st_print_one_digit();
    case "print-zero-digit": return st_print_zero_digit();
    case "cleanup": return st_cleanup();
    default:
      setMsg("Unknown state: "+state);
      state = "halt";
      return;
  }
}

/* --- begin: print @ then 1, move to new --- */
function st_begin() {
  if (!sub) { sub = "P@"; log(`begin: write @ at F[0]`); writeF(SENTINEL); render(); return; }
  if (sub === "P@") { sub = "R"; moveR(); log(`begin: R → head=${head}`); render(); return; }
  if (sub === "R") { sub = "P1"; writeF("1"); log(`begin: write 1`); render(); return; }
  // end begin
  sub = null;
  state = "new";
  log(`→ state: new`);
}

/* --- new: move head to leftmost digit on F, then mark-digits --- */
function st_new() {
  // Move to sentinel then to leftmost digit
  if (!sub) { sub = "to-left"; log(`new: move head left to sentinel @`); render(); return; }
  if (sub === "to-left") {
    if (readF() === SENTINEL) { sub = "to-rightmost"; log(`new: at @; move to rightmost printed digit`); render(); return; }
    moveL(); render(); return;
  }
  if (sub === "to-rightmost") {
    // ensure head ends at the last printed digit (where new digit will be appended)
    // we’ll stop at the first blank after the last digit
    if (readF()===BLANK) { moveL(); sub = "ready"; render(); return; }
    moveR(); render(); return;
  }
  if (sub === "ready") {
    // head is at last digit; next: mark-digits
    sub = null;
    state = "mark-digits";
    log(`→ state: mark-digits`);
  }
}

/* --- mark-digits: mark known digits (x), unknown as z, and print least-significant r in E --- */
function st_mark_digits() {
  if (!sub) {
    sub = "mark-known";
    // position: at last known digit on F; walk left and mark all known digits with x on E-right of them
    ctx.markIndex = null;
    log(`mark-digits: mark known digits with x; unknown with z; print one r in E`);
    return render();
  }
  if (sub === "mark-known") {
    // place x’s on E above/below the digit positions (we follow book using markers on the F track visually; we’ll show them actually on F):
    const d = readF();
    if (d==="0"||d==="1") {
      // Mark current digit with x (if not already marked)
      if (d!=="x" && d!=="y" && d!=="z") {
        writeF(d); // keep digit as is visually; we’ll place marker *next* to it using an E mark to the right per Turing "marking"
        // For visualization we’ll add an x in E just to the right of F cell (book: “print a symbol to the right of a figure”)
        if ((E[head+1]??BLANK)===BLANK) E[head+1] = "x";
      }
      moveL();
      render();
      return;
    }
    // reached sentinel @
    sub = "unknown-digit";
    return;
  }
  if (sub === "unknown-digit") {
    // The unknown next digit (assumed 1) gets marked as z.
    // In book it’s printed to the right of its square; for clarity, put 'z' in E just to the right of the blank future F digit square.
    // Move right to last known, then one right to the blank (unknown)
    if (readF()!==SENTINEL) { moveL(); render(); return; }
    // go to last known digit
    while (readF()!==BLANK) moveR();
    // now we’re at first blank (unknown digit square)
    if ((E[head]??BLANK)===BLANK) E[head]="z"; // mark z at E aligned with unknown digit
    sub = "place-first-r";
    render();
    return;
  }
  if (sub === "place-first-r") {
    // print one r in least significant place of running total (leftmost E space after moving two R’s in book sequence)
    // For clarity we’ll put an 'r' several cells to the right of sentinel on E; the exact spacing is not important visually,
    // but we’ll follow the book by creating a small block of r’s later.
    // Set head at position of that r:
    moveR(); moveR();
    if (readE()===BLANK) writeE("r");
    sub = null;
    state = "first-r";
    log(`→ state: first-r (initialize running total r…r)`);
    render();
  }
}

/* --- first-r / last-r: initialize 7-digit running total (r’s) for the “assume last digit = 1” pass --- */
function st_first_r() {
  if (!sub) {
    sub = "make-7-r";
    ctx.rCount = 1;
    log(`first-r: initialize running total with 7 digits (r…r), LSB on the left`);
    return render();
  }
  if (sub === "make-7-r") {
    moveR(); // next E cell
    if (readE()===BLANK) writeE("r");
    ctx.rCount++;
    render();
    if (ctx.rCount >= 7) { sub = null; state = "last-r"; log(`→ state: last-r`); }
  }
}
function st_last_r() {
  // handoff to multiplication
  state = "find-digits";
  sub = "seek-first";
  // set x/y/z pairing to start: z on unknown (square itself), means x and y coincide there.
  // we already placed a z marker at unknown E cell aligned with blank F
  log(`→ state: find-digits (bit-by-bit multiplication begins)`);
  render();
}

/* --- find-digits: choose next (x,y) or (z) product; decide add-zero / add-one --- */
function st_find_digits() {
  if (sub === "seek-first") {
    // Go back to sentinel, then find first marked digit (x/y/z) scanning right
    if (readF()===SENTINEL) { sub="scan-right"; log(`find-digits: from @ scan right for first x/y/z`); render(); return; }
    moveL(); render(); return;
  }
  if (sub === "scan-right") {
    const f = readF(); const e = readE();
    if (e==="x"||e==="y"||e==="z") { sub = "found-1st"; log(`find-digits: found first marker ${e}`); render(); return; }
    moveR(); render(); return;
  }
  if (sub === "found-1st") {
    const e = readE();
    // if first is 'x' or 'y' or 'z':
    if (e==="x"||e==="y"||e==="z") {
      // If the figure at F under it is 0 → add-zero directly
      const f = F[head-1] ?? BLANK; // marking is printed to the right of digit in book, so digit is to the left
      const digit = (f==="1") ? 1 : 0;
      if (digit===0) {
        sub = null; state = "add-zero";
        log(`found-1st-digit: digit 0 → add-zero`);
        return render();
      }
      // else digit is 1 → we need second marked digit if first was x or y; if z, it's self-product → add-one
      if (e==="z") {
        sub = null; state = "add-one"; ctx.overflow = false;
        log(`found-1st-digit: z → 1×1 → add-one`);
        return render();
      }
      // need to locate 2nd marked digit (the other of x/y)
      sub = "find-2nd";
      ctx.firstWas = e;
      log(`find-2nd-digit: looking for other marker to pair with ${e}`);
      return render();
    }
  }
  if (sub === "find-2nd") {
    // search for the other marker (x or y)
    moveR();
    const e = readE();
    if ((ctx.firstWas==="x" && e==="y") || (ctx.firstWas==="y" && e==="x")) {
      // second digit is under (digit at left of the marker)
      const f = F[head-1] ?? BLANK;
      const digit2 = (f==="1") ? 1 : 0;
      if (digit2===0) { sub=null; state="add-zero"; log(`found-2nd-digit: second digit 0 → add-zero`); render(); return; }
      sub=null; state="add-one"; ctx.overflow=false;
      log(`found-2nd-digit: 1×1 → add-one`);
      render();
      return;
    }
    render();
    return;
  }

  // safety / fallthrough: if we get here, loop
  if (!sub) { sub="seek-first"; }
}

/* --- add-zero: change first r→s or u→v to advance add position (no value change) --- */
function st_add_zero() {
  const res = rtAdvancePosition();
  log(`add-zero: advance add pos at E[${res.i}] ${res.from}→${res.to}`);
  state = "add-finished";
  sub = null;
  render();
}

/* --- add-one: write into running total at current position; may cause carry/overflow --- */
function st_add_one() {
  const res = rtAddOneWithCarry();
  log(`add-one: wrote ${res.wrote} at E[${res.index}] ${res.carry? "(carry)":""}${res.overflow?" (overflow)":""
  }`);
  if (res.overflow) {
    // overflow -> new-digit-is-zero
    state = "new-digit-is-zero";
    sub = "to-sentinel";
    log(`→ state: new-digit-is-zero (overflow means product ≥ 2)`);
  } else {
    state = "add-finished";
    sub = null;
  }
  render();
}

/* --- carry: (unused as standalone; handled inside add-one above, but kept for completeness) --- */
function st_carry() {
  // Not used; our add-one handles carry fully. Keep for completeness.
  state = "add-finished"; sub = null; render();
}

/* --- add-finished: shift markers; if y about to hit sentinel → new-digit-is-one --- */
function st_add_finished() {
  if (!sub) { sub="to-sentinel"; log(`add-finished: move to sentinel to shift markers`); render(); return; }
  if (sub==="to-sentinel") {
    if (readF()===SENTINEL) { sub="erase-old-x"; state="erase-old-x"; log(`→ state: erase-old-x`); render(); return; }
    moveL(); render(); return;
  }
}

/* --- erase-old-x: if 'x' found, erase; if 'z', turn it to 'y'; then move to next E-left and print-new-x --- */
function st_erase_old_x() {
  if (!sub) { sub="scan-right"; log(`erase-old-x: scan right for x or z`); render(); return; }
  if (sub==="scan-right") {
    if (readE()==="x") { writeE(BLANK); sub="to-left-two"; log(`erase-old-x: erased x at ${head}`); render(); return; }
    if (readE()==="z") { writeE("y"); sub="to-left-two"; log(`erase-old-x: z→y at ${head}`); render(); return; }
    moveR(); render(); return;
  }
  if (sub==="to-left-two") {
    moveL(); moveL(); sub=null; state="print-new-x"; log(`→ state: print-new-x`); render(); return;
  }
}

/* --- print-new-x: print x one digit to left; if would cross sentinel, go to erase-old-y --- */
function st_print_new_x() {
  // We want to place next x one digit left from previous x/y position relative to number digits.
  // For simplicity: place an x at next available E cell to the left of the last pair.
  if (!sub) { sub="seek-left-spot"; ctx.guard=0; log(`print-new-x: place x one digit to the left`); render(); return; }
  if (sub==="seek-left-spot") {
    if (readF()===SENTINEL) {
      // x would shift into sentinel → need to shift y left instead
      sub=null; state="erase-old-y"; log(`print-new-x: x would cross @ → erase-old-y`); render(); return;
    }
    // find a safe spot: move left until we find a digit square; then put x in E just to right of it
    const leftDigit = F[head-1] ?? BLANK;
    moveL();
    if (leftDigit==="0"||leftDigit==="1") {
      // place x to the right of that digit position
      if ((E[head+1]??BLANK)===BLANK) { E[head+1]="x"; }
      sub=null; state="find-digits"; log(`print-new-x: printed x, continue find-digits`); render(); return;
    }
    render();
    return;
  }
}

/* --- erase-old-y: if y found and next would hit sentinel → new-digit-is-one, else shift y left and reset-new-x --- */
function st_erase_old_y() {
  if (!sub) { sub="scan-right"; log(`erase-old-y: scan right for y`); render(); return; }
  if (sub==="scan-right") {
    if (readE()==="y") { writeE(BLANK); sub="check-sentinel"; log(`erase-old-y: erased y @ ${head}`); render(); return; }
    moveR(); render(); return;
  }
  if (sub==="check-sentinel") {
    // if next y move would be into sentinel, then multiplication ended without overflow → new-digit-is-one
    // Simple criterion: if we are very near sentinel on the left (few steps), treat as done.
    // More robust: if no more x’s exist to the left of the least digit, assume done.
    const hasRoomLeft = (() => {
      for (let i=0;i<head;i++) if (F[i]==="0"||F[i]==="1") return true;
      return false;
    })();
    if (!hasRoomLeft) {
      sub=null; state="new-digit-is-one"; log(`erase-old-y: y would hit sentinel → new-digit-is-one`); render(); return;
    }
    sub="print-new-y";
    state="print-new-y";
    log(`→ state: print-new-y`);
    render();
  }
}

/* --- print-new-y: print y one digit to the left; then reset-new-x to rightmost (unknown) --- */
function st_print_new_y() {
  if (!sub) { sub="seek-left-spot"; log(`print-new-y: place y one digit to the left`); render(); return; }
  if (sub==="seek-left-spot") {
    moveL();
    // place y to the right of the next digit to left
    const leftDigit = F[head] ?? BLANK;
    if (leftDigit==="0"||leftDigit==="1") {
      if ((E[head+1]??BLANK)===BLANK) E[head+1] = "y";
      sub=null; state="reset-new-x"; log(`print-new-y: y printed; → reset-new-x`); render(); return;
    }
    render();
    return;
  }
}

/* --- reset-new-x: x -> least significant digit (unknown) --- */
function st_reset_new_x() {
  if (!sub) { sub="to-unknown"; log(`reset-new-x: set x to the unknown (rightmost) digit position`); render(); return; }
  if (sub==="to-unknown") {
    // move to first blank F cell (unknown digit)
    while (readF()!==BLANK) moveR();
    // place x marker at E aligned with unknown digit
    E[head] = "x";
    sub=null; state="flag-result-digits";
    log(`reset-new-x: x placed @ unknown; → flag-result-digits`);
    render();
  }
}

/* --- flag-result-digits: convert first s/v → t/w to shift add position --- */
function st_flag_result_digits() {
  const res = flagResultDigits();
  if (res) log(`flag-result-digits: E[${res.i}] ${res.from}→${res.to}`);
  else log(`flag-result-digits: no s/v found (edge case)`);
  state = "unflag-result-digits";
  sub = null;
  render();
}

/* --- unflag-result-digits: remaining s/v → r/u --- */
function st_unflag_result_digits() {
  const changed = unflagResultDigits();
  log(`unflag-result-digits: converted remaining s/v → r/u`);
  state = "find-digits";
  sub = "seek-first";
  render();
}

/* --- new-digit-is-one: back to sentinel, then print 1 in blank digit cell; cleanup --- */
function st_new_digit_is_one() {
  if (!sub) { sub="to-sentinel"; log(`new-digit-is-one: go to @`); render(); return; }
  if (sub==="to-sentinel") {
    if (readF()===SENTINEL) { sub="print"; log(`new-digit-is-one: at @ → print 1 in next blank digit`); render(); return; }
    moveL(); render(); return;
  }
  if (sub==="print") {
    // go to first blank digit on F
    while (readF()!==BLANK) moveR();
    writeF("1");
    sub=null; state="cleanup"; log(`print-one-digit: wrote 1 → cleanup`); render(); return;
  }
}

/* --- new-digit-is-zero: similar, but print 0 --- */
function st_new_digit_is_zero() {
  if (!sub) { sub="to-sentinel"; log(`new-digit-is-zero: go to @`); render(); return; }
  if (sub==="to-sentinel") {
    if (readF()===SENTINEL) { sub="print"; log(`new-digit-is-zero: at @ → print 0 in next blank digit`); render(); return; }
    moveL(); render(); return;
  }
  if (sub==="print") {
    while (readF()!==BLANK) moveR();
    writeF("0");
    sub=null; state="cleanup"; log(`print-zero-digit: wrote 0 → cleanup`); render(); return;
  }
}

/* --- cleanup: erase running total and markers; return to new --- */
function st_cleanup() {
  if (!sub) { sub="erase-E"; ctx.cleanupIndex=0; log(`cleanup: erase E-squares (running total and markers)`); render(); return; }
  if (sub==="erase-E") {
    if (ctx.cleanupIndex >= E.length) {
      sub=null; state="new"; log(`cleanup done → new (next digit)`); render(); return;
    }
    E[ctx.cleanupIndex++] = BLANK;
    render();
    return;
  }
}

/*** Controls ***/
document.getElementById("btnStep").addEventListener("click", ()=> {
  if (!running) { step(); }
});
document.getElementById("btnRun").addEventListener("click", ()=> {
  if (running) return;
  running = true;
  const speedSel = document.getElementById("speed");
  const delay = parseInt(speedSel.value, 10);
  timer = setInterval(()=> {
    step();
  }, delay);
});
document.getElementById("btnPause").addEventListener("click", ()=> {
  running = false;
  clearInterval(timer);
});
document.getElementById("btnReset").addEventListener("click", ()=> {
  running = false;
  clearInterval(timer);
  initialize();
});

/*** Boot: after DOM ready, perform initial begin sequence to show @ and first 1 like book ***/
(function autoBoot(){
  // Run two steps to lay @ and move, one to write 1, then pause for user
  // (We keep it manual so users can step from the very start if they prefer.)
})();
</script>
</body>
</html>
